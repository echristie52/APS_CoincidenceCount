'''
tifParser.py
Eric Christie
10/18/22
BYU QCX Project

Summary: Takes in a file generated by XIA XMAP Digital X-ray Processor
            with event energy and time information. Current configuration
            is saved in a .tif format. This information is translated to 
            an array and parsed into pairs for coincidence analysis.
'''

from PIL import Image
import numpy as np


#file information
folder = "testFiles"
filename = "dryRun_noSource"
startDigit = 4
filename_full = folder + "/" + filename + "_" + f'{startDigit:03d}' + ".tif"

#difference in optical lengths
dist_difference = 0 #in meters
ch_shorterPath = 0
ch_longerPath = 1

#energy distribution
energy_22keV_lowerLimit = 0
energy_22keV_upperLimit = 8191


#Constants
specialEvent_mask = 0x8000 #bit 15 (MSB)
rolloverCh_mask = 0x000F #last nibble, 0x810x
ch_mask = 0x6000 #bits 14-13
energy_mask = 0x1FFF #bits 12-0
clockPeriod = 20 * 10**-9 #20 ns
rolloverEvent_mask = 0x0100 #checks rollover vs end of buffer

rollover_timeValue = 2**32

# Functions
def combineTo32bits(num1, num2): #combines 2 word numbers
    output = (num1 << 16) + num2
    if output < 0:
        output += 2**32
    return output

def calculateLineDelay(dist): #returns num of clks in lineDelay
    c = 299792458 #m/s
    timeDifference = dist / c # (m) / (m/s) = (s)
    numClocks = timeDifference / clockPeriod # (s) / (s/clk) = (clk)
    return int(numClocks)

def checkTime(timeVal, time_pair):
    if timeVal == time_pair: #exact match
        return True
    elif timeVal == (time_pair -1) % rollover_timeValue: #-1 clk
        return True
    elif timeVal == (time_pair +1) % rollover_timeValue: #+1 clk
        return True
    else:                   #no match
        return False

def checkEnergy(energy1, energy2):
    energySum = energy1 + energy2
    if energySum > energy_22keV_lowerLimit and energySum < energy_22keV_upperLimit:
        return True
    else:
        return False


#open file as array
im = Image.open(filename_full)
rawArray = np.array(im)
rawArray = rawArray[0]
header = rawArray[0:255]
print(filename_full)





#parses the data
eventData = []
ch_overruns = [0,0,0,0] #records num of time overruns for ch0-1
eventsPerCh = [0,0,0,0]


#arrange data array into event tuples: [ch, energy, timestamp]
for i in range(256, len(rawArray), 3):
    word = rawArray[i]
    if(word & specialEvent_mask): #adds timer overrun count to channel
        if (word & rolloverEvent_mask): #channel timer overrun
            ch = word & rolloverCh_mask
            ch_overruns[ch] += 1
    
    else: #regular photon event
        ch = int((word & ch_mask) >> 13)
        energy = word & energy_mask
        timeStamp = combineTo32bits(rawArray[i+2], rawArray[i+1])
        event = [ch, energy, timeStamp]

        if not(event == [0,0,0]): #clears null data (fills unused section of buffer)
            eventData.append(event)
            eventsPerCh[ch] += 1


#Statistics
print("Events processed: " + str(len(eventData)))


#coincident counting begins
coincidenceCount = 0
coincidenceTime = calculateLineDelay(dist_difference)
for i in range(len(eventData)):
    if eventData[i][0] == ch_shorterPath:
        time_pair = (eventData[i][2] + coincidenceTime) % rollover_timeValue #projects time value, accounts for rollover

        for j in range(i+1, len(eventData)): #looks ahead at photons
            if eventData[j][2] > time_pair+1: #won't look past expected time
                break
            elif eventData[j][0] == ch_longerPath: #expected ch
                if checkTime(eventData[j][2], time_pair): #expected time
                    if checkEnergy(eventData[i][1], eventData[j][1]): #expected energy sum
                        coincidenceCount += 1
                        print("Coincidence: " + str(eventData[i]) + "\n\t     " + str(eventData[j]))

print("Total Coincidences: " + str(coincidenceCount))

#output time elapsed during file
timeStart = eventData[0][2]
timeEnd = eventData[len(eventData) -1][2]
num_overruns = ch_overruns[ch_shorterPath] #should be equal

totalClks = (rollover_timeValue - timeStart) + timeEnd + (num_overruns * rollover_timeValue)
totalTime_sec = totalClks * clockPeriod # clks * sec/clk = sec
totalTime_min = totalTime_sec / 60
totalTime_hr = totalTime_min / 60

print("Total Time Elapsed: " + str(totalTime_min) + " minutes")


# Rate
print("Rate: " + str(coincidenceCount / totalTime_min) + " coincidences/min")

#can write some diagnostic to analyze recorded indeces









