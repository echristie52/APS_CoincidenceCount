'''
tifDiagnostic.py
Eric Christie
11/30/22
BYU QCX Project

Summary: Takes in a file generated by XIA XMAP Digital X-ray Processor
            with event energy and time information. Current configuration
            is saved in a .tif format. This pulls out key information
            for verification.
'''

from PIL import Image
import numpy as np
import matplotlib
from matplotlib import pyplot as plt

#file information
filename = "dryRun_noSource"
startDigit = 1
filename_full = filename + "_" + f'{startDigit:03d}' + ".tif"




#Constants
specialEvent_mask = 0x8000 #bit 15 (MSB)
rolloverEvent_mask = 0x0100 #checks rollover vs end of buffer
rolloverCh_mask = 0x000F #last nibble, 0x810x
ch_mask = 0x6000 #bits 14-13
energy_mask = 0x1FFF #bits 12-0
clockPeriod = 20 * 10**-9 #20 ns

# Functions
def combineTo32bits(num1, num2): #combines 2 word numbers
    output = (num1 << 16) + num2
    if output < 0:
        output += 2**32
    return output


##### Choose Outputs #####
print_raw_buffer = False #prints raw header and binary data
print_raw_header = False #prints full header
check_basic_settings = False #checks basic settings in header
check_data_stats = False #prints num of words, num events, etc
show_processed_data = False #print data info
print_rollovers = False #prints each time a channel overruns (and current progress through data)
print_upper_time_word = False #prints time word at beginning of buffer
plot_energy_distribution = False #plots energy distribution of phtons
graph_time_stamps = True #graphs timestamps regardless of channel
special_test = False #section used for non-standard tests (seeing a specific entry, etc)


#open file as array
im = Image.open(filename_full)
rawArray = np.array(im)
rawArray = rawArray[0]
header = rawArray[0:255]
print(filename_full)


if print_raw_buffer:
    print("header")
    print(hex(rawArray[0]))
    print(hex(rawArray[1]))
    for i in range(2,255):
        print(rawArray[i])

    print("data")
    for i in range(256, 256+300, 3):
        print(bin(rawArray[i]) + ", " + str(rawArray[i+1]) + ", " + str(rawArray[i+2]))

if print_raw_header:
    for i in range(256):
        print(str(i) + ": " + str(rawArray[i]))

if check_basic_settings:
    #Checks header information
    headerCheck = [[0, 0x55AA],     #tag word
                    [1, 0xAA55],    #tag word
                    [2, 256],       #header length
                    [3,3],          #Mapping Mode (General List)
                    [64, 2],        #list mode variant (E & Clk)
                    [65, 3]]        #words per event

    #checks above information in file header
    for i in range(len(headerCheck)):
        if(header[headerCheck[i][0]] != headerCheck[i][1]):
            print("Header Error(" + str(headerCheck[i][0]) + "): expected " + str(headerCheck[i][1]) + ", read " + str(header[headerCheck[i][0]]))
    print("Check Complete")

if print_upper_time_word:
    #channel statistics
    print("Upper Time Words:")
    for i in range(68, 110, 12):
        print("\t" + str(combineTo32bits(header[i+5], header[i+4])))



#parses the data
eventData = []
ch_overruns = [0,0,0,0] #records num of time overruns for ch0-1
eventsPerCh = [0,0,0,0]


#arrange data array into event tuples: [ch, energy, timestamp]
for i in range(256, len(rawArray), 3):
    word = rawArray[i]
    if(word & specialEvent_mask): #adds timer overrun count to channel
        if (word & rolloverEvent_mask): #channel timer overrun
            ch = word & rolloverCh_mask
            ch_overruns[ch] += 1
            if print_rollovers:
                print("Rollover: ch" + str(ch) + "\t" + str(len(eventData))) #prints ch and progress through data
        else: #end of buffer record
            totalWords = combineTo32bits(rawArray[i+2], rawArray[i+1]) #total num words (incl header)
    
    else:
        ch = int((word & ch_mask) >> 13)
        energy = word & energy_mask
        timeStamp = combineTo32bits(rawArray[i+2], rawArray[i+1])
        event = [ch, energy, timeStamp]

        if not(event == [0,0,0]):
            eventData.append(event)
            eventsPerCh[ch] += 1


if show_processed_data:
    for i in range(len(eventData)):
        print(eventData[i])

if special_test:
    print(min(eventData[:][2]))
    print(max(eventData[:][2]))

if check_data_stats:
    #extracts header statistics to confirm with data
    numWords = combineTo32bits(header[26], header[25])
    numEvents_total = combineTo32bits(header[67], header[66])
    numEvents_ch = []
    for i in range(68,105,12): #ch0-1
        numEvents_ch.append(combineTo32bits(header[i+1], header[i]))
    numEvents_special = combineTo32bits(header[117], header[116])
    #Statistics
    print("\tHeader\tObserved")
    print("Total Words: " + str(numWords) + "\t" + str(totalWords-256))
    print("Total Events: " + str(numEvents_total) + "\t" + str(len(eventData))) 
    for ch in range(4):
        print("\tch" + str(ch) + ": " + str(numEvents_ch[ch]) + "\t"  + str(eventsPerCh[ch]))
    print("Special Events: " + str(numEvents_special) + "\t" + str(sum(ch_overruns)))
    for ch in range(4):
        print("\tch" + str(ch) + ": " + str(ch_overruns[ch]))
    print("Buffer Length: " + str(len(rawArray)))

if graph_time_stamps:
    x = np.arange(len(eventData))
    y = []
    for events in eventData: #exracts each time stamp
        y.append(events[2])
    #print(len(x))
    #print(len(y))
    plt.plot(x,y)
    plt.title("Timestamps")
    plt.xlabel("Photon Event")
    plt.ylabel("Time")
    plt.show()




if plot_energy_distribution:
#Energy distribution per channel and total
    energyDistribution = [[],[],[],[]]
    for event in eventData:
        ch = event[0]
        energy = event[1]
        energyDistribution[ch].append(energy) #sorts evergy by ch

    xlim = 1000 #change based on data
    for i in range(4):
        plt.subplot(5,1,i+1)
        plt.hist(energyDistribution[i])
        plt.xlim(0,xlim)
    plt.subplot(5,1,5)
    plt.hist(energyDistribution)
    plt.xlim(0,xlim)
    plt.legend()
    plt.show()




